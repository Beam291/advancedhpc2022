# -*- coding: utf-8 -*-
"""PrfSon.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aIa1ei2mPOds4KL0T-4HjZL5II6_7Aqu
"""
from numba import cuda
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import time
import math

root = mpimg.imread('../img/lion.jpg')
# imgplot = plt.imshow(root)
# plt.show()

@cuda.jit 
def calV(src, dst): 
    tidx = cuda.threadIdx.x + cuda.blockIdx.x * cuda.blockDim.x
    tidy = cuda.threadIdx.y + cuda.blockIdx.y * cuda.blockDim.y

    R = src[tidx, tidy, 2]/255
    G = src[tidx, tidy, 1]/255
    B = src[tidx, tidy, 0]/255
    
    dst[tidx, tidy, 0] = max(R, G, B)
    

img = root.copy()
print(img[0])
print(img[0][0])
print(img[0][0][1])
devdata = cuda.to_device(img)
devOutput = cuda.device_array((img.shape[0], img.shape[1], 1),np.float64)


blockSize = (8,8)
gridSize = (math.ceil(img.shape[0] / blockSize[0]), math.ceil(img.shape[1] / blockSize[1]))
calV[gridSize, blockSize](devdata, devOutput)

v_mat = devOutput.copy_to_host()
'''
print(len(v_mat))
print(len(v_mat[0]))
print(len(v_mat[0][0]))
print(v_mat[0][0][0])
print(v_mat)
'''

print(v_mat[10])

@cuda.jit(device=True)
def calDS(cMat,vMat,fw,a,b,c,d):
  windowSum = 0
  windowSD = 0
  windowColor = 0
  for i in range(a,b):
    for j in range(c,d):
      if i < 0 or i > (len(vMat[0])) or j < 0 or j > (len(vMat[0][0])):
        windowSum += 0
        windowColor += 0
      else:
        windowSum += vMat[i][j][0]
        windowColor += cMat[i][j]
  windowMean = windowSum/(fw*fw)
        
  for i in range(a,b):
    for j in range(c,d):
      if i < 0 or i > (len(vMat[0])) or j < 0 or j > (len(vMat[0][0])):
        windowSD += (windowMean*windowMean)/(fw*fw-1)
      else:
        windowSD += (vMat[i][j][0] - windowMean)*(vMat[i][j][0] - windowMean)/(fw*fw-1)
        
  result = math.sqrt(windowSD)
  windowMeanColor = windowColor/(fw*fw)
  return result, windowMeanColor

@cuda.jit
def kuwahara(src, dst, w, cmat):
  tidx = cuda.threadIdx.x + cuda.blockIdx.x * cuda.blockDim.x
  tidy = cuda.threadIdx.y + cuda.blockIdx.y * cuda.blockDim.y

  dsA, colorA = calDS(cmat, src, w, tidx - w, tidx, tidy - w, tidy)
  dsB, colorB = calDS(cmat, src, w, tidx, tidx + w, tidy - w, tidy)
  dsC, colorC = calDS(cmat, src, w, tidx - w, tidx, tidy, tidy + w)
  dsD, colorD = calDS(cmat, src, w, tidx, tidx + w, tidy, tidy + w)
      
  minWl = min(dsA, dsB, dsC, dsD)
    
  if minWl == dsA:
    dst[tidx, tidy] = colorA
  if minWl == dsB:
    dst[tidx, tidy] = colorB
  if minWl == dsC:
    dst[tidx, tidy] = colorC
  if minWl == dsD:
    dst[tidx, tidy] = colorD
      

devdata1 = cuda.to_device(v_mat)
devOutput1 = cuda.device_array((img.shape[0], img.shape[1]),np.uint8)

blockSize = (8,8)
gridSize = (math.ceil(img.shape[0] / blockSize[0]), math.ceil(img.shape[1] / blockSize[1]))
window_size = 3

red_channel = np.ascontiguousarray(img[:,:,2])
kuwahara[gridSize, blockSize](devdata1, devOutput1, window_size, red_channel)
red_mat = devOutput1.copy_to_host()

green_channel = np.ascontiguousarray(img[:,:,1])
kuwahara[gridSize, blockSize](devdata1, devOutput1, window_size, green_channel)
green_mat = devOutput1.copy_to_host()

blue_channel = np.ascontiguousarray(img[:,:,0])
kuwahara[gridSize, blockSize](devdata1, devOutput1, window_size, blue_channel)
blue_mat = devOutput1.copy_to_host()


kuwaImg = np.dstack((blue_mat, green_mat, red_mat))
print(kuwaImg)

plt.imshow(kuwaImg)
plt.show()